## MonkeyBT 基于手动栈实现的高性能行为树

MonkeyBT 基于手动栈实现，正常遍历时不需要从根节点开始遍历，而是直接从栈顶取出正在运行中的节点执行。由于执行指针在树中上上下下，犹如一只猴子爬树，因此本库取名 MonkeyBT。

除此之外，MonkeyBT还支持多种特性：

- 手动栈实现BT inline，维持高性能的情况下，保持代码逻辑简单，更容易理解。
- 实时事件响应：用户可以设置OnEvent，实时响应突发事件。
- Cancel机制：支持Task的Cancel逻辑，避免BT Cancel时无法清理
- 离散Update：通过实时事件响应+next predict支持离散的Update功能，在高频tick的情况下同时保持性能和响应速度。

### 原理介绍

**行为树内联**：

按照行为树的定义，每次执行Update时需要从根遍历至正在Running的节点，这样才能保证处于中间的节点每次Update都被处理。但是这样也会引入一个较大的遍历开销，因为对于大部分中间节点来说，只需要在进入节点和子节点完成时才有逻辑，每次的行为树遍历是无用且浪费性能的。

一些之前的行为树实现针对这个问题做了内联（或者叫短路）的优化，在运行行为树时，在当前节点上存储一个内联指针跳过子树中哪些不需要每次都运行的中间节点，指向正在RUNNING的叶子节点或者是需要每次运行的中间节点。但是这样处理有个问题，就是实现比较复杂，因为开发者需要去维护这个内联指针应该指向哪里。

MonkeyBT 提供一种新的设计思路来解决这个问题，用一个手动栈来模拟从根节点到叶节点的递归调用。这样的好处时，当发现叶节点处于RUNNING时，立即就可以停止运行栈，保持RUNNING节点在栈顶（而不是像函数调用那样强迫地回到最外层（排空栈））。同样地，当再次运行BT时，MonkeyBT立即就可以访问到位于栈顶端的RUNNING节点（而不是需要从根节点递归地找到RUNNING节点）。在叶节点完成后，MonkeyBT可以继续地从栈顶pop出需要处理的节点，这样就达到了跟递归处理一样的处理顺序，保持了结构一致性和简单容易理解。

MonkeyBT 还需要处理两个问题，1. 如何支持哪些每次Update都需要处理的节点（例如alwaysGuard）；2. 如何支持节点同时运行多个子树（例如parallel）。答案是由这些节点重建手动栈，管理它们的子树（多个子树）。对这些节点所在的树来说，它们就是叶节点，因此始终处于栈顶，每次Update时保证被执行。对这些节点的子树来说，这些节点重建了栈，又可以跳过无需访问的中间节点。

**实时事件响应**：

在一些高频tick（例如每秒8个tick）的场景下，每个tick都执行行为树是浪费的，因此引入了一些叶节点依靠外部信号（事件）来驱动任务完成。一些之前的行为树依靠把信号推迟到下个BT Update去处理来完成信号驱动，但这么做是违背初衷的，引入信号本身是为了在低于tick的Update中更快的响应信号，这个初始目的反而被抛弃了。

但在MonkeyBT 中响应信号就变得非常简单，因为我们可以非常快速地访问到正在Runing的叶节点（栈顶），并要求它们响应信号，如果叶节点无法响应信号或者响应信号后仍为Running就可以无视，如果响应信号后任务完成，就可以转到正常的行为树执行，因为本来就不在递归中，所以切换起来相当流畅。

**离散Update**：

如果启用了实时事件响应，那我们就可以不需要每个tick都去Update行为树，那么应该多久Update一次行为树呢？你可能会认为大概每过n个tick Update一次行为树就可以了吧，其实有更好的方式，如果叶节点任务能在每次Update时给出一个预估的下次时间，那我们就可以完全依赖这个预估值规划下一次Update，对于多个Running叶节点的情况，取最小值即可。在这种情况下，如果要打断叶节点执行，依靠alwaysGuard就不行了，需要将所有的打断检测全部转化为事件响应才可以。哦，对了，如果你需要中间节点也能响应信号提前退出，那么这个中间节点也应该重建手动栈才可以哦。
